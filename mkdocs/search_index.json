{
    "docs": [
        {
            "location": "/",
            "text": "i3configger\n\u00b6\n\n\nDisclaimer:\n this is a tool aimed at users who already know how the configuration of \ni3\n works (as described in the \nexcellent docs\n). i3configger is an independent add-on, not directly affiliated with the project and in no way necessary to use i3 productively. It is strictly command line oriented and a file based using a very slight enhancement of the existing i3 configuration format with some json sprinkled on top. If you are looking for a graphical tool to help you create a configuration, check out the \nresources below\n.\n\n\nWhy?\n\u00b6\n\n\nI3 already has a very nice and simple configuration system. i3configger makes it a bit more malleable by making it possible to send \"messages\" to your configuration to change variables or to switch between alternative sub configurations (e.g. different color schemes). This is done by adding a build step that can be triggered by calling i3configger directly or by running it as a watcher process that automatically rebuilds and reloads when source files change or sending a message.\n\n\nDetailed Features\n\u00b6\n\n\n\n\nbuild main config and one or several i3status configs from the same sources\n\n\nvariables are handled slightly more intelligently than i3 does it (variables assigned to other variables are resolved)\n\n\nvariables in i3status configs are also resolved (set anywhere in the sources)\n\n\nreload or restart i3 when a change has been done (using \ni3-msg\n)\n\n\nnotify when new config has been created and activated (using \nnotify-send\n)\n\n\nsimple way to render partials based on key value pairs in file name\n\n\nsimple way to change the configuration by sending messages\n\n\nbuild config as one shot script or watch for changes\n\n\nsend messages to watching i3configger process\n\n\nif \ni3 -C -c <path to new config>\n fails with the newly rendered config, the old config will be kept, no harm done",
            "title": "Home"
        },
        {
            "location": "/#i3configger",
            "text": "Disclaimer:  this is a tool aimed at users who already know how the configuration of  i3  works (as described in the  excellent docs ). i3configger is an independent add-on, not directly affiliated with the project and in no way necessary to use i3 productively. It is strictly command line oriented and a file based using a very slight enhancement of the existing i3 configuration format with some json sprinkled on top. If you are looking for a graphical tool to help you create a configuration, check out the  resources below .",
            "title": "i3configger"
        },
        {
            "location": "/#why",
            "text": "I3 already has a very nice and simple configuration system. i3configger makes it a bit more malleable by making it possible to send \"messages\" to your configuration to change variables or to switch between alternative sub configurations (e.g. different color schemes). This is done by adding a build step that can be triggered by calling i3configger directly or by running it as a watcher process that automatically rebuilds and reloads when source files change or sending a message.",
            "title": "Why?"
        },
        {
            "location": "/#detailed-features",
            "text": "build main config and one or several i3status configs from the same sources  variables are handled slightly more intelligently than i3 does it (variables assigned to other variables are resolved)  variables in i3status configs are also resolved (set anywhere in the sources)  reload or restart i3 when a change has been done (using  i3-msg )  notify when new config has been created and activated (using  notify-send )  simple way to render partials based on key value pairs in file name  simple way to change the configuration by sending messages  build config as one shot script or watch for changes  send messages to watching i3configger process  if  i3 -C -c <path to new config>  fails with the newly rendered config, the old config will be kept, no harm done",
            "title": "Detailed Features"
        },
        {
            "location": "/installation/",
            "text": "Installation\n\u00b6\n\n\nNote\n the code needs at least Python 3.6. I want to play with the new toys :)\n\n\ni3configger\n is released on \nthe Python Package Index\n.\n\n\nStandard way\n\u00b6\n\n\nThe standard installation method is:\n\n\n$ pip install i3configger\n\n\n\nor install in the system Python:\n\n\n$ sudo pip install i3configger\n\n\n\nInstall into a virtualenv\n\u00b6\n\n\n$ python -m venv /path/to/new/venv\n$ source /path/to/new/venv/bin/activate\n$ pip install i3configger\n\n\n\nsee more about venvs in the \nPython documentation\n.\n\n\nInstall and run from a clone with tox\n\u00b6\n\n\ntox\n is a versatile tool to automate testing and development activities. As it also takes care of the management of virtualenvs it can be used to run i3configger in a tox generated virtualenv. tox is usually packaged in a reasonably recent version for most distributions as installable through your package manager as \npython-tox\n.\n\n\nTo install i3configger in a tox managed virtualenv and start it in foreground watch mode directly from source, do:\n\n\n$ git clone https://github.com/obestwalter/i3configger.git\n$ cd i3configger\n$ tox -e i3configger -- --watch",
            "title": "Installation"
        },
        {
            "location": "/installation/#installation",
            "text": "Note  the code needs at least Python 3.6. I want to play with the new toys :)  i3configger  is released on  the Python Package Index .",
            "title": "Installation"
        },
        {
            "location": "/installation/#standard-way",
            "text": "The standard installation method is:  $ pip install i3configger  or install in the system Python:  $ sudo pip install i3configger",
            "title": "Standard way"
        },
        {
            "location": "/installation/#install-into-a-virtualenv",
            "text": "$ python -m venv /path/to/new/venv\n$ source /path/to/new/venv/bin/activate\n$ pip install i3configger  see more about venvs in the  Python documentation .",
            "title": "Install into a virtualenv"
        },
        {
            "location": "/installation/#install-and-run-from-a-clone-with-tox",
            "text": "tox  is a versatile tool to automate testing and development activities. As it also takes care of the management of virtualenvs it can be used to run i3configger in a tox generated virtualenv. tox is usually packaged in a reasonably recent version for most distributions as installable through your package manager as  python-tox .  To install i3configger in a tox managed virtualenv and start it in foreground watch mode directly from source, do:  $ git clone https://github.com/obestwalter/i3configger.git\n$ cd i3configger\n$ tox -e i3configger -- --watch",
            "title": "Install and run from a clone with tox"
        },
        {
            "location": "/getting-started/",
            "text": "Getting started\n\u00b6\n\n\nWARNING\n going ahead will overwrite your existing config file, so make sure your config is under source control and/or you have a backup. i3configger will create a backup of your old config but only one, so running i3configger twice will leave no trace of your original configuration file.\n\n\nHaving that out of the way: simply running i3configger once you have it installed should get you set up nicely.\n\n\n$ i3configger -vv\n\n\n\nyields something like:\n\n\n2017-06-08 19:25:49,131 i3configger.main:main:28 INFO: set i3 refresh method to <bound method I3.reload_i3 of <class 'i3configger.ipc.I3'>>\n2017-06-08 19:25:49,131 i3configger.base:set_notify_command:54 DEBUG: do not send notifications\n2017-06-08 19:25:49,131 i3configger.config:fetch:159 INFO: read config from /home/oliver/.i3/config.d/i3configger.json\n2017-06-08 19:25:49,132 i3configger.config:fetch:161 DEBUG: use:\n{'bars': {'defaults': {'key': 'i3status',\n                       'target': '..',\n                       'template': 'tpl',\n                       'value': 'default'},\n          'targets': {}},\n 'main': {'target': '../config'}}\n2017-06-08 19:25:49,132 i3configger.config:fetch:159 INFO: read config from /home/oliver/.i3/config.d/.state.json\n2017-06-08 19:25:49,132 i3configger.config:fetch:161 DEBUG: use:\n{'select': {}, 'set': {}}\n2017-06-08 19:25:49,133 i3configger.config:__init__:43 DEBUG: initialized config  I3configgerConfig:\n{'barTargets': {},\n 'configPath': PosixPath('/home/oliver/.i3/config.d/i3configger.json'),\n 'mainTargetPath': PosixPath('/home/oliver/.i3/config'),\n 'message': None,\n 'partialsPath': PosixPath('/home/oliver/.i3/config.d'),\n 'payload': {'bars': {'defaults': {'key': 'i3status',\n                                   'target': '..',\n                                   'template': 'tpl',\n                                   'value': 'default'},\n                      'targets': {}},\n             'main': {'target': '../config'}},\n 'state': {'select': {}, 'set': {}},\n 'statePath': PosixPath('/home/oliver/.i3/config.d/.state.json')}\n2017-06-08 19:25:49,134 i3configger.partials:select:92 DEBUG: selected:\n[Partial(config.conf)]\n\n\n\n\nWhat happened?\n\u00b6\n\n\n\n\na structure like this has been created in your \ni3\n folder:\n\n\n\n\n.\n \u251c\u2500\u2500 README.md\n \u251c\u2500\u2500 config\n \u2514\u2500\u2500 config.d\n  \u00a0\u00a0 \u251c\u2500\u2500 .state.json\n  \u00a0\u00a0 \u251c\u2500\u2500 config.conf\n  \u00a0\u00a0 \u2514\u2500\u2500 i3configger.json\n\n\n\n\n\n\n\n\nyour config has been copied verbatim to \nconfig.d/config.conf\n so that you can now turn it into a malleable, chunky i3configger config as you see fit.\n\n\n\n\n\n\na new config file has been generated instead of your old config (which should still be basically the same as your old one).\n\n\n\n\n\n\na backup of the last config was created with \n.bak\n\n\n\n\n\n\ni3configger.json\n can be used to do configuration of the status bars.\n\n\n\n\n.state.json\n remembers the state of your current settings\n\n\n\n\nWatch files in the background\n\u00b6\n\n\nIf you are experimenting with the config and want it automatically updated on change:\n\n\nrun it in the foreground:\n\n\n$ i3configger --watch\n\n\n\nrun it as a daemon:\n\n\n$ i3configger --daemon\n\n\n\nstop the daemon:\n\n\n$ i3configger --kill",
            "title": "Getting started"
        },
        {
            "location": "/getting-started/#getting-started",
            "text": "WARNING  going ahead will overwrite your existing config file, so make sure your config is under source control and/or you have a backup. i3configger will create a backup of your old config but only one, so running i3configger twice will leave no trace of your original configuration file.  Having that out of the way: simply running i3configger once you have it installed should get you set up nicely.  $ i3configger -vv  yields something like:  2017-06-08 19:25:49,131 i3configger.main:main:28 INFO: set i3 refresh method to <bound method I3.reload_i3 of <class 'i3configger.ipc.I3'>>\n2017-06-08 19:25:49,131 i3configger.base:set_notify_command:54 DEBUG: do not send notifications\n2017-06-08 19:25:49,131 i3configger.config:fetch:159 INFO: read config from /home/oliver/.i3/config.d/i3configger.json\n2017-06-08 19:25:49,132 i3configger.config:fetch:161 DEBUG: use:\n{'bars': {'defaults': {'key': 'i3status',\n                       'target': '..',\n                       'template': 'tpl',\n                       'value': 'default'},\n          'targets': {}},\n 'main': {'target': '../config'}}\n2017-06-08 19:25:49,132 i3configger.config:fetch:159 INFO: read config from /home/oliver/.i3/config.d/.state.json\n2017-06-08 19:25:49,132 i3configger.config:fetch:161 DEBUG: use:\n{'select': {}, 'set': {}}\n2017-06-08 19:25:49,133 i3configger.config:__init__:43 DEBUG: initialized config  I3configgerConfig:\n{'barTargets': {},\n 'configPath': PosixPath('/home/oliver/.i3/config.d/i3configger.json'),\n 'mainTargetPath': PosixPath('/home/oliver/.i3/config'),\n 'message': None,\n 'partialsPath': PosixPath('/home/oliver/.i3/config.d'),\n 'payload': {'bars': {'defaults': {'key': 'i3status',\n                                   'target': '..',\n                                   'template': 'tpl',\n                                   'value': 'default'},\n                      'targets': {}},\n             'main': {'target': '../config'}},\n 'state': {'select': {}, 'set': {}},\n 'statePath': PosixPath('/home/oliver/.i3/config.d/.state.json')}\n2017-06-08 19:25:49,134 i3configger.partials:select:92 DEBUG: selected:\n[Partial(config.conf)]",
            "title": "Getting started"
        },
        {
            "location": "/getting-started/#what-happened",
            "text": "a structure like this has been created in your  i3  folder:   .\n \u251c\u2500\u2500 README.md\n \u251c\u2500\u2500 config\n \u2514\u2500\u2500 config.d\n  \u00a0\u00a0 \u251c\u2500\u2500 .state.json\n  \u00a0\u00a0 \u251c\u2500\u2500 config.conf\n  \u00a0\u00a0 \u2514\u2500\u2500 i3configger.json    your config has been copied verbatim to  config.d/config.conf  so that you can now turn it into a malleable, chunky i3configger config as you see fit.    a new config file has been generated instead of your old config (which should still be basically the same as your old one).    a backup of the last config was created with  .bak    i3configger.json  can be used to do configuration of the status bars.   .state.json  remembers the state of your current settings",
            "title": "What happened?"
        },
        {
            "location": "/getting-started/#watch-files-in-the-background",
            "text": "If you are experimenting with the config and want it automatically updated on change:  run it in the foreground:  $ i3configger --watch  run it as a daemon:  $ i3configger --daemon  stop the daemon:  $ i3configger --kill",
            "title": "Watch files in the background"
        },
        {
            "location": "/concept/",
            "text": "Concept\n\u00b6\n\n\nThe configuration is built from so called \npartials\n in \n<i3 config folder>/config.d\n. For very simple usages (just changing some variable for examples) it is not even necessary to spread the configuration over several files though. Have a look at the \nexamples\n to get an idea about how it can be used.\n\n\nI use this to generate \nmy own i3 config\n. Here are the config partials and settings: \n.i3/config.d\n, from which \nconfig\n and all \ni3status.*conf\n files are built.\n\n\nChanges that are made to the configuration via i3configger messages are not written back to the \npartials\n but are persisted in a \n.state.json\n in the source folder. This file is used to override variables and choose alternative files during build. Deleting that file puts everything back to normal.\n\n\nTerms\n\u00b6\n\n\n\n\n\n\npartials\n: the i3 configuration (including status bars and theirs configuration files - if configured) is built from files in \nconfig.d\n that make up the parts of the configuration to be built. They contain exactly what a normal configuration for i3 would contain only spread over several files (including status bar config files) - with somme added functionality mainly variable solution, alternatives and bar configurations from templates.\n\n\n\n\n\n\nmessage\n: when invoking i3configger with positional arguments they constitute a simple message to the configuration, effectively triggering a build with the changes requested in the message.\n\n\n\n\n\n\nMessage \"mini language\"\n\u00b6\n\n\nset <vraiable> <value>\n assigns a new value to any variable that is set anywhere in the configuration (note: variable name is passed without leading \n$\n sign).\n\n\nselect\n chooses a \npartial\n from a group of alternatives following the naming scheme \n<key>.<value>.conf\n.\n\n\n\n\nselect-next\n, \nselect-previous\n chooses the next/previous \npartial\n from a group of alternatives (in lexical order).\n\n\n\n\nChange variables with \nset\n\u00b6\n\n\nA lot in the i3 configuration can be changed by changing the value of variables. i3configger adds an interface to change them with a (very, very, very) simple messaging language.\n\n\nOne example would be to switch aspects of the status bar(s) - for example mode and position:\n\n\nA configuration containing:\n\n\nset $bar_mode hidden\nset $bar_position top\n...\nbar {\n    ...\n    mode $bar_mode\n    position $bar_position\n}\n\n\n\n\ncan be manipulated by invoking:\n\n\n$ i3configger set bar_mode dock\n$ i3configger set bar_position bottom\n\n\n\n\n... and the bar is docked after the first command and jumps to the bottom after the second message has been sent.\n\n\nThis is completely generic. All variables you set anywhere in the configuration can be changed by this.\n\n\nWarning about variables\n\u00b6\n\n\nThe implementation of this is very simple (it just parses all variables and an optional message into a single dictionary and uses \nPython Template String\n to do the substitutions. To i3configger all \n$varName\n are the same and will be replaced with their value wherever they are.\n\n\nThis could bite you if you are not aware of that and use regular expressions containing \n$\n e.g. in \nfor_window\n. So make sure that you do not use an expression where a part containing \n$whatever\n also matches an existing variable that was assigned with \nset $whatever\n.\n\n\nSwitching between alternatives with \nselect\n\u00b6\n\n\nBigger changes can be done by switching between \npartials\n. To realize this there is a simple naming convention for \npartials\n to mark them as alternatives of which only ever one is integrated into the final configuration.\n\n\nThe following \npartials\n form a group of alternatives:\n\n\n~/.i3/config.d/scheme.blue.conf\n~/.i3/config.d/scheme.red.conf\n~/.i3/config.d/scheme.black.conf\n\n\n\nThe first part of the file (\nscheme\n) serves as the key of that group of alternatives and the second part (\nblue\n, \nred\n, \nblack\n) is the value that can be chosen.\n\n\nTo choose a concrete alternative:\n\n\n$ i3configger select scheme red\n\n\n\n\nTo cycle through these different alternatives:\n\n\n$ i3configger select-next scheme\n$ i3configger select-previous scheme\n\n\n\n\nHow you call your groups and their values is completely up to you, as long as you stick with the naming convention.\n\n\nSpecial conventions\n\u00b6\n\n\nAutomatic selection for hostname\n\u00b6\n\n\nAt the moment there is one special name that I deem useful to be populated differently, which is \nhostname\n. If you have \npartials\n in you \nconfig.d\n that follow the scheme \nhostname.<whatever>.conf\n they will automatically be chosen if your hostname matches \nwhatever\n.\n\n\ndeactivate partials in \nconfig.d\n\u00b6\n\n\nIf you want to deactivate a partial, you can do that by prepending a \n.\n to the file name, e.g. \n.whatever.conf\n or \n.whatever.else.conf\n are not included in the build even if they reside in your \nconfig.d\n.\n\n\nBonus track: keep it DRY\n\u00b6\n\n\nUsing i3configger you can also:\n\n\n\n\nassign variables to variables (\nset $someVar $someOtherVar\n)\n\n\nUse variables set anywhere in config \npartials\n in i3status configuration files\n\n\ngenerate \nbar {...}\n settings from templates with some extra config.",
            "title": "Concept"
        },
        {
            "location": "/concept/#concept",
            "text": "The configuration is built from so called  partials  in  <i3 config folder>/config.d . For very simple usages (just changing some variable for examples) it is not even necessary to spread the configuration over several files though. Have a look at the  examples  to get an idea about how it can be used.  I use this to generate  my own i3 config . Here are the config partials and settings:  .i3/config.d , from which  config  and all  i3status.*conf  files are built.  Changes that are made to the configuration via i3configger messages are not written back to the  partials  but are persisted in a  .state.json  in the source folder. This file is used to override variables and choose alternative files during build. Deleting that file puts everything back to normal.",
            "title": "Concept"
        },
        {
            "location": "/concept/#terms",
            "text": "partials : the i3 configuration (including status bars and theirs configuration files - if configured) is built from files in  config.d  that make up the parts of the configuration to be built. They contain exactly what a normal configuration for i3 would contain only spread over several files (including status bar config files) - with somme added functionality mainly variable solution, alternatives and bar configurations from templates.    message : when invoking i3configger with positional arguments they constitute a simple message to the configuration, effectively triggering a build with the changes requested in the message.",
            "title": "Terms"
        },
        {
            "location": "/concept/#message-mini-language",
            "text": "set <vraiable> <value>  assigns a new value to any variable that is set anywhere in the configuration (note: variable name is passed without leading  $  sign).  select  chooses a  partial  from a group of alternatives following the naming scheme  <key>.<value>.conf .   select-next ,  select-previous  chooses the next/previous  partial  from a group of alternatives (in lexical order).",
            "title": "Message \"mini language\""
        },
        {
            "location": "/concept/#change-variables-with-set",
            "text": "A lot in the i3 configuration can be changed by changing the value of variables. i3configger adds an interface to change them with a (very, very, very) simple messaging language.  One example would be to switch aspects of the status bar(s) - for example mode and position:  A configuration containing:  set $bar_mode hidden\nset $bar_position top\n...\nbar {\n    ...\n    mode $bar_mode\n    position $bar_position\n}  can be manipulated by invoking:  $ i3configger set bar_mode dock\n$ i3configger set bar_position bottom  ... and the bar is docked after the first command and jumps to the bottom after the second message has been sent.  This is completely generic. All variables you set anywhere in the configuration can be changed by this.",
            "title": "Change variables with set"
        },
        {
            "location": "/concept/#warning-about-variables",
            "text": "The implementation of this is very simple (it just parses all variables and an optional message into a single dictionary and uses  Python Template String  to do the substitutions. To i3configger all  $varName  are the same and will be replaced with their value wherever they are.  This could bite you if you are not aware of that and use regular expressions containing  $  e.g. in  for_window . So make sure that you do not use an expression where a part containing  $whatever  also matches an existing variable that was assigned with  set $whatever .",
            "title": "Warning about variables"
        },
        {
            "location": "/concept/#switching-between-alternatives-with-select",
            "text": "Bigger changes can be done by switching between  partials . To realize this there is a simple naming convention for  partials  to mark them as alternatives of which only ever one is integrated into the final configuration.  The following  partials  form a group of alternatives:  ~/.i3/config.d/scheme.blue.conf\n~/.i3/config.d/scheme.red.conf\n~/.i3/config.d/scheme.black.conf  The first part of the file ( scheme ) serves as the key of that group of alternatives and the second part ( blue ,  red ,  black ) is the value that can be chosen.  To choose a concrete alternative:  $ i3configger select scheme red  To cycle through these different alternatives:  $ i3configger select-next scheme\n$ i3configger select-previous scheme  How you call your groups and their values is completely up to you, as long as you stick with the naming convention.",
            "title": "Switching between alternatives with select"
        },
        {
            "location": "/concept/#special-conventions",
            "text": "",
            "title": "Special conventions"
        },
        {
            "location": "/concept/#automatic-selection-for-hostname",
            "text": "At the moment there is one special name that I deem useful to be populated differently, which is  hostname . If you have  partials  in you  config.d  that follow the scheme  hostname.<whatever>.conf  they will automatically be chosen if your hostname matches  whatever .",
            "title": "Automatic selection for hostname"
        },
        {
            "location": "/concept/#deactivate-partials-in-configd",
            "text": "If you want to deactivate a partial, you can do that by prepending a  .  to the file name, e.g.  .whatever.conf  or  .whatever.else.conf  are not included in the build even if they reside in your  config.d .",
            "title": "deactivate partials in config.d"
        },
        {
            "location": "/concept/#bonus-track-keep-it-dry",
            "text": "Using i3configger you can also:   assign variables to variables ( set $someVar $someOtherVar )  Use variables set anywhere in config  partials  in i3status configuration files  generate  bar {...}  settings from templates with some extra config.",
            "title": "Bonus track: keep it DRY"
        },
        {
            "location": "/build-process/",
            "text": "Build process\n\u00b6\n\n\n\n\nmerge all files that fit the conditions and configuration\n\n\nread in all lines that fit the pattern \nset $.*\n\n\nparse them into a map key -> value\n\n\nResolve all indirect assignments (e.g. \nset $bla $blub\n)\n\n\nReplace all variables in configs with their values (bar configs get\n   local context merged before substitution)\n\n\nWrite results\n\n\nCheck if config is valid - if not switch back to saved backup",
            "title": "Build process"
        },
        {
            "location": "/build-process/#build-process",
            "text": "merge all files that fit the conditions and configuration  read in all lines that fit the pattern  set $.*  parse them into a map key -> value  Resolve all indirect assignments (e.g.  set $bla $blub )  Replace all variables in configs with their values (bar configs get\n   local context merged before substitution)  Write results  Check if config is valid - if not switch back to saved backup",
            "title": "Build process"
        },
        {
            "location": "/resources/",
            "text": "Resources\n\u00b6\n\n\nI3 official\n\u00b6\n\n\n\n\ni3wm\n\n\ni3wm reddit group (FAQs)\n\n\nArchlinux Wiki\n\n\n\n\nOther Tools\n\u00b6\n\n\n... from the i3wm ecosystem\n\n\n\n\nonline color configurator\n\n\nj4-make-config (i3-theme)\n\n\ni3-style\n\n\ni3ColourChanger\n\n\ni3-manager",
            "title": "Resources"
        },
        {
            "location": "/resources/#resources",
            "text": "",
            "title": "Resources"
        },
        {
            "location": "/resources/#i3-official",
            "text": "i3wm  i3wm reddit group (FAQs)  Archlinux Wiki",
            "title": "I3 official"
        },
        {
            "location": "/resources/#other-tools",
            "text": "... from the i3wm ecosystem   online color configurator  j4-make-config (i3-theme)  i3-style  i3ColourChanger  i3-manager",
            "title": "Other Tools"
        }
    ]
}